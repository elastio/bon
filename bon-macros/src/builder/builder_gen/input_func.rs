use super::{
    generic_param_to_arg, AssocMethodCtx, AssocMethodReceiverCtx, BuilderGenCtx, FinishFunc,
    FinishFuncBody, Generics, Member, MemberOrigin, RawMember, StartFunc,
};
use crate::builder::params::BuilderParams;
use crate::normalization::NormalizeSelfTy;
use crate::util::prelude::*;
use darling::util::SpannedValue;
use darling::FromMeta;
use proc_macro2::Span;
use quote::quote;
use std::rc::Rc;
use syn::punctuated::Punctuated;
use syn::visit::Visit;
use syn::visit_mut::VisitMut;

#[derive(Debug, FromMeta)]
pub(crate) struct FuncInputParams {
    expose_positional_fn: Option<SpannedValue<ExposePositionalFnParams>>,

    #[darling(flatten)]
    base: BuilderParams,
}

#[derive(Debug, Default)]
struct ExposePositionalFnParams {
    name: Option<syn::Ident>,
    vis: Option<syn::Visibility>,
}

impl FromMeta for ExposePositionalFnParams {
    fn from_meta(meta: &syn::Meta) -> Result<Self> {
        match meta {
            syn::Meta::Path(_) => {
                return Ok(Self::default());
            }
            syn::Meta::NameValue(meta) => {
                let val = &meta.value;
                let name = syn::parse2(quote!(#val))?;

                return Ok(Self { name, vis: None });
            }
            syn::Meta::List(_) => {}
        }

        #[derive(Debug, FromMeta)]
        struct Full {
            name: Option<syn::Ident>,
            vis: Option<syn::Visibility>,
        }

        let full = Full::from_meta(meta)?;

        let me = Self {
            name: full.name,
            vis: full.vis,
        };

        Ok(me)
    }
}

pub(crate) struct FuncInputCtx {
    pub(crate) orig_func: syn::ItemFn,
    pub(crate) norm_func: syn::ItemFn,
    pub(crate) impl_ctx: Option<Rc<ImplCtx>>,
    pub(crate) params: FuncInputParams,
}

pub(crate) struct ImplCtx {
    pub(crate) self_ty: Box<syn::Type>,
    pub(crate) generics: syn::Generics,

    /// Lint suppressions from the original item that will be inherited by all items
    /// generated by the macro. If the original syntax used `#[expect(...)]`,
    /// then it must be represented as `#[allow(...)]` here.
    pub(crate) allow_attrs: Vec<syn::Attribute>,
}

impl FuncInputCtx {
    fn self_ty_prefix(&self) -> Option<String> {
        let prefix = self
            .impl_ctx
            .as_deref()?
            .self_ty
            .last_path_segment_ident()?
            .to_string();

        Some(prefix)
    }

    fn assoc_method_ctx(&self) -> Option<AssocMethodCtx> {
        Some(AssocMethodCtx {
            self_ty: self.impl_ctx.as_deref()?.self_ty.clone(),
            receiver: self.assoc_method_receiver_ctx(),
        })
    }

    fn assoc_method_receiver_ctx(&self) -> Option<AssocMethodReceiverCtx> {
        let receiver = self.norm_func.sig.receiver()?;
        let self_ty = &self.impl_ctx.as_deref()?.self_ty;

        let mut without_self_keyword = receiver.ty.clone();

        NormalizeSelfTy { self_ty }.visit_type_mut(&mut without_self_keyword);

        Some(AssocMethodReceiverCtx {
            with_self_keyword: receiver.clone(),
            without_self_keyword,
        })
    }

    fn generics(&self) -> Generics {
        let impl_ctx = self.impl_ctx.as_ref();
        let norm_func_params = &self.norm_func.sig.generics.params;
        let params = impl_ctx
            .map(|impl_ctx| merge_generic_params(&impl_ctx.generics.params, norm_func_params))
            .unwrap_or_else(|| norm_func_params.iter().cloned().collect());

        let where_clauses = [
            self.norm_func.sig.generics.where_clause.clone(),
            impl_ctx.and_then(|impl_ctx| impl_ctx.generics.where_clause.clone()),
        ];

        let where_clause = where_clauses
            .into_iter()
            .flatten()
            .reduce(|mut combined, clause| {
                combined.predicates.extend(clause.predicates);
                combined
            });

        Generics::new(params, where_clause)
    }

    fn builder_ident(&self) -> syn::Ident {
        if let Some(builder_type) = &self.params.base.builder_type {
            return builder_type.clone();
        }

        if self.is_method_new() {
            return quote::format_ident!("{}Builder", self.self_ty_prefix().unwrap_or_default());
        }

        let pascal_case_func = self.norm_func.sig.ident.snake_to_pascal_case();

        quote::format_ident!(
            "{}{pascal_case_func}Builder",
            self.self_ty_prefix().unwrap_or_default(),
        )
    }

    pub(crate) fn adapted_func(&self) -> Result<syn::ItemFn> {
        let mut orig = self.orig_func.clone();

        let params = self.params.expose_positional_fn.as_ref();

        orig.vis = params
            .map(|params| {
                params
                    .vis
                    .clone()
                    // If exposing of positional fn is enabled without an explicit
                    // visibility, then just use the visibility of the original function.
                    .unwrap_or_else(|| self.norm_func.vis.clone())
            })
            // By default we change the positional function's visibility to private
            // to avoid exposing it to the surrounding code. The surrounding code is
            // supposed to use this function through the builder only.
            //
            // Not that this doesn't guarantee that adjacent code in this module can't
            // access the function, therefore we rename it below.
            .unwrap_or(syn::Visibility::Inherited);

        let orig_ident = orig.sig.ident.clone();

        if let Some(params) = params {
            let has_no_value = matches!(
                params.as_ref(),
                ExposePositionalFnParams {
                    name: None,
                    vis: None,
                }
            );

            if has_no_value && !self.is_method_new() {
                bail!(
                    &params.span(),
                    "Positional function identifier is required. It must be \
                    specified with `#[builder(expose_positional_fn = function_name_here)]`"
                )
            }
        }

        orig.sig.ident = params
            .and_then(|params| {
                params
                    .name
                    .clone()
                    // We treat `new` method specially. In this case we already know the best
                    // default name for the positional function, which is `new` itself.
                    .or_else(|| self.is_method_new().then(|| orig.sig.ident))
            })
            // By default we don't want to expose the positional function, so we
            // hide it under a generated name to avoid name conflicts.
            .unwrap_or_else(|| quote::format_ident!("__orig_{}", orig_ident.raw_name()));

        strip_known_attrs_from_args(&mut orig.sig);

        // Remove all doc comments from the function itself to avoid docs duplication
        // which may lead to duplicating doc tests, which in turn implies repeated doc
        // tests execution, which means worse tests performance.
        //
        // Also remove any `#[builder]` attributes that were meant for this proc macro.
        orig.attrs
            .retain(|attr| !attr.is_doc() && !attr.path().is_ident("builder"));

        let prefix = self
            .self_ty_prefix()
            .map(|self_ty_prefix| format!("{self_ty_prefix}::"))
            .unwrap_or_default();

        let builder_entry_fn_link = format!("{prefix}{orig_ident}",);

        let doc = format!(
            "Positional function equivalent of [`{builder_entry_fn_link}()`].\n\
            See its docs for details.",
        );

        orig.attrs.push(syn::parse_quote!(#[doc = #doc]));

        if self.params.expose_positional_fn.is_none() {
            orig.attrs.extend([syn::parse_quote!(#[doc(hidden)])]);
        }
        orig.attrs.push(syn::parse_quote!(#[allow(
            // It's fine if there are too many positional arguments in the function
            // because the whole purpose of this macro is to fight with this problem
            // at the call site by generating a builder, while keeping the fn definition
            // site the same with tons of positional arguments which don't harm readability
            // there because their names are explicitly specified at the definition site.
            clippy::too_many_arguments,

            // It's fine to use many bool arguments in the function signature because
            // all of the will be named at the call site
            clippy::fn_params_excessive_bools,
        )]));

        Ok(orig)
    }

    fn is_method_new(&self) -> bool {
        self.impl_ctx.is_some() && self.norm_func.sig.ident == "new"
    }

    pub(crate) fn into_builder_gen_ctx(self) -> Result<BuilderGenCtx> {
        let receiver = self.assoc_method_ctx();

        if self.impl_ctx.is_none() {
            let explanation = "\
                but #[bon] attribute \
                is absent on top of the impl block. This additional #[bon] \
                attribute on the impl block is required for the macro to see \
                the type of `Self` and properly generate the builder struct \
                definition adjacently to the impl block.";

            if let Some(receiver) = &self.orig_func.sig.receiver() {
                bail!(
                    &receiver.self_token,
                    "Function contains a `self` parameter {explanation}"
                );
            }

            let mut ctx = FindSelfReference::default();
            ctx.visit_item_fn(&self.orig_func);
            if let Some(self_span) = ctx.self_span {
                bail!(
                    &self_span,
                    "Function contains a `Self` type reference {explanation}"
                );
            }
        }

        let builder_ident = self.builder_ident();

        fn typed_args(func: &syn::ItemFn) -> impl Iterator<Item = &syn::PatType> {
            func.sig.inputs.iter().filter_map(syn::FnArg::as_typed)
        }

        let members = typed_args(&self.norm_func)
            .zip(typed_args(&self.orig_func))
            .map(|(norm_arg, orig_arg)| {
                let pat = match norm_arg.pat.as_ref() {
                    syn::Pat::Ident(pat) => pat,
                    _ => bail!(
                        &orig_arg.pat,
                        "use a simple `identifier: type` syntax for the function argument; \
                        destructuring patterns in arguments aren't supported by the `#[builder]`",
                    ),
                };

                Ok(RawMember {
                    attrs: &norm_arg.attrs,
                    ident: pat.ident.clone(),
                    norm_ty: norm_arg.ty.clone(),
                    orig_ty: orig_arg.ty.clone(),
                })
            })
            .collect::<Result<Vec<_>>>()?;

        let members = Member::from_raw(MemberOrigin::FnArg, members)?;

        let generics = self.generics();

        let finish_func_body = FnCallBody {
            sig: self.adapted_func()?.sig,
            impl_ctx: self.impl_ctx.clone(),
        };

        let is_method_new = self.is_method_new();

        // Special case for `new` methods. We rename them to `builder`
        // since this is the name that is used in the builder pattern
        let start_func_ident = if is_method_new {
            quote::format_ident!("builder")
        } else {
            self.norm_func.sig.ident.clone()
        };

        let finish_func_ident = self.params.base.finish_fn.unwrap_or_else(|| {
            // For `new` methods the `build` finisher is more conventional
            if is_method_new {
                quote::format_ident!("build")
            } else {
                quote::format_ident!("call")
            }
        });

        let finish_func = FinishFunc {
            ident: finish_func_ident,
            unsafety: self.norm_func.sig.unsafety,
            asyncness: self.norm_func.sig.asyncness,
            must_use: get_must_use_attribute(&self.norm_func.attrs)?,
            body: Box::new(finish_func_body),
            output: self.norm_func.sig.output,
            docs: "Finishes building and performs the requested action.".to_owned(),
        };

        let fn_allows = self
            .norm_func
            .attrs
            .iter()
            .filter_map(syn::Attribute::to_allow);

        let allow_attrs = self
            .impl_ctx
            .as_ref()
            .into_iter()
            .flat_map(|impl_ctx| impl_ctx.allow_attrs.iter().cloned())
            .chain(fn_allows)
            .collect();

        let start_func = StartFunc {
            ident: start_func_ident,

            // No override for visibility for the start fn is provided here.
            // It's supposed to be the same as the original function's visibility.
            vis: None,

            attrs: self
                .norm_func
                .attrs
                .into_iter()
                .filter(<_>::is_doc)
                .collect(),

            // Override on the start fn to use the the generics from the
            // target function itself. We don't need to duplicate the generics
            // from the impl block here.
            generics: Some(Generics::new(
                Vec::from_iter(self.norm_func.sig.generics.params),
                self.norm_func.sig.generics.where_clause,
            )),
        };

        let ctx = BuilderGenCtx {
            members,

            allow_attrs,

            conditional_params: self.params.base.on,
            builder_derives: self.params.base.derive,

            builder_ident,

            assoc_method_ctx: receiver,
            generics,
            vis: self.norm_func.vis,

            start_func,
            finish_func,
        };

        Ok(ctx)
    }
}

struct FnCallBody {
    sig: syn::Signature,
    impl_ctx: Option<Rc<ImplCtx>>,
}

impl FinishFuncBody for FnCallBody {
    fn generate(&self, members: &[Member]) -> TokenStream2 {
        let asyncness = &self.sig.asyncness;
        let maybe_await = asyncness.is_some().then(|| quote!(.await));

        // Filter out lifetime generic arguments, because they are not needed
        // to be specified explicitly when calling the function. This also avoids
        // the problem that it's not always possible to specify lifetimes in
        // the turbofish syntax. See the problem of late-bound lifetimes specification
        // in the issue https://github.com/rust-lang/rust/issues/42868
        let generic_args = self
            .sig
            .generics
            .params
            .iter()
            .filter(|arg| !matches!(arg, syn::GenericParam::Lifetime(_)))
            .map(generic_param_to_arg);

        let prefix = self
            .sig
            .receiver()
            .map(|receiver| {
                let self_token = &receiver.self_token;
                quote!(#self_token.__private_receiver.)
            })
            .or_else(|| {
                let self_ty = &self.impl_ctx.as_deref()?.self_ty;
                Some(quote!(<#self_ty>::))
            });

        let func_ident = &self.sig.ident;

        // The variables with values of members are in scope for this expression.
        let member_vars = members.iter().map(Member::orig_ident);

        quote! {
            #prefix #func_ident::<#(#generic_args,)*>(
                #( #member_vars ),*
            )
            #maybe_await
        }
    }
}

/// Remove all doc comments attributes from function arguments, because they are
/// not valid in that position in regular Rust code. The cool trick is that they
/// are still valid syntactically when a proc macro like this one pre-processes
/// them and removes them from the expanded code. We use the doc comments to put
/// them on the generated setter methods.
///
/// We also strip all `builder(...)` attributes because this macro processes them
/// and they aren't needed in the output.
fn strip_known_attrs_from_args(sig: &mut syn::Signature) {
    for arg in &mut sig.inputs {
        arg.attrs_mut()
            .retain(|attr| !attr.is_doc() && !attr.path().is_ident("builder"));
    }
}

/// To merge generic params we need to make sure lifetimes are always the first
/// in the resulting list according to Rust syntax restrictions.
fn merge_generic_params(
    left: &Punctuated<syn::GenericParam, syn::Token![,]>,
    right: &Punctuated<syn::GenericParam, syn::Token![,]>,
) -> Vec<syn::GenericParam> {
    let is_lifetime = |param: &&_| matches!(param, &&syn::GenericParam::Lifetime(_));

    let (left_lifetimes, left_rest): (Vec<_>, Vec<_>) = left.iter().partition(is_lifetime);
    let (right_lifetimes, right_rest): (Vec<_>, Vec<_>) = right.iter().partition(is_lifetime);

    left_lifetimes
        .into_iter()
        .chain(right_lifetimes)
        .chain(left_rest)
        .chain(right_rest)
        .cloned()
        .collect()
}

#[derive(Default)]
struct FindSelfReference {
    self_span: Option<Span>,
}

impl Visit<'_> for FindSelfReference {
    fn visit_item(&mut self, _: &syn::Item) {
        // Don't recurse into nested items. We are interested in the reference
        // to `Self` on the current item level
    }

    fn visit_path(&mut self, path: &syn::Path) {
        if self.self_span.is_some() {
            return;
        }
        syn::visit::visit_path(self, path);

        let first_segment = match path.segments.first() {
            Some(first_segment) => first_segment,
            _ => return,
        };

        if first_segment.ident == "Self" {
            self.self_span = Some(first_segment.ident.span());
        }
    }
}

fn get_must_use_attribute(attrs: &[syn::Attribute]) -> Result<Option<syn::Attribute>> {
    let mut iter = attrs
        .iter()
        .filter(|attr| attr.meta.path().is_ident("must_use"));

    let result = iter.next();

    if let Some(second) = iter.next() {
        bail!(
            second,
            "Found multiple #[must_use], but bon only works with exactly one (or less)."
        );
    }

    if let Some(attr) = result {
        if let syn::AttrStyle::Inner(_) = attr.style {
            bail!(
                attr,
                "The #[must_use] attribute must be placed on the function itself, \
                not inside it."
            );
        }
    }

    Ok(result.cloned())
}
