//! @Veetaha encountered a bug when working on big changes to `bon` where
//! the generic params generated by the macro were named the same as the
//! type of the member, and thus leading to a name conflict. This test is
//! here to catch any such simple regression.
use crate::prelude::*;

struct User;

#[test]
fn member_and_type_named_the_same_fn() {
    #[builder]
    fn sut(_user: User) {}

    sut().user(User).call();
}

#[test]
fn member_and_type_named_the_same_struct() {
    #[builder]
    struct Sut {
        _user: User,
    }

    #[bon]
    impl Sut {
        #[builder]
        fn sut(_user: User) {}
    }

    let _ = Sut::builder().user(User).build();
    Sut::sut().user(User).call();
}
