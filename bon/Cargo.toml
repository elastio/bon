[package]
name    = "bon"
version = "2.3.0"

description = "Next-gen compile-time-checked builder generator, named function's arguments, and more!"

categories = [
  "rust-patterns",
  "data-structures",
  "asynchronous",
  "no-std",
  "no-std::no-alloc",
]
keywords = ["builder", "macro", "derive", "constructor", "setter"]

edition    = "2021"
homepage   = "https://bon-rs.com/"
license    = "MIT OR Apache-2.0"
repository = "https://github.com/elastio/bon"

# This MSRV was chosen because Rust supports mixing generic type and const
# parameters only starting with this version. We require this feature for the
# cases when the builder is generated for a function or struct that uses const
# generics. The generated builder **always** appends a generic type parameter
# for the type state at the end of the Builder generics list. So for functions
# or structs that use const generics the generated builder will have a generic
# type parameter after the const generic parameter, which is only supported
# starting from Rust 1.59.0.
rust-version = "1.59.0"

[package.metadata.docs.rs]
all-features = true

# Generate clickable links in the source code view in the docs
rustdoc-args = ["--generate-link-to-definition"]

# We don't need the docs to be built for every first-tier target.
# This crate is not platform-specific.
targets = ["x86_64-unknown-linux-gnu"]

[lints]
workspace = true

[dependencies]
# The version of the macro crate is pinned to a specific one because the code
# generated by the macros uses private APIs from the runtime crate that are not
# guarded by semver.
bon-macros  = { path = "../bon-macros", version = "=2.3.0" }
rustversion = "1"

[dev-dependencies]
# Using a bit older version that supports our MSRV
expect-test = "1.4.1"

# Using a bit older version that supports our MSRV
tokio = { version = "1.29.1", features = ["macros", "rt-multi-thread"] }

# Using a bit older version that supports our MSRV
trybuild = "1.0.89"

[features]
alloc   = []
default = ["std"]
std     = ["alloc"]

# Opts in to the higher MSRV 1.79.0. In this version, Rust stabilized the syntax
# for bounds in associated type position which can be used to make bounds on generic
# associated types implied. See the release announcement for more:
# https://blog.rust-lang.org/2024/06/13/Rust-1.79.0.htmlbounds-in-associated-type-position
#
# This feature is useful for the trait `IsComplete` generated by the builder macros.
# When this feature is enabled, the builder macros use the new syntax for bounds in
# associated type position, which enables implied `IsSet` bounds for the type state
# of required members.
#
# To understand how this can be used consider the following example:
#
# ```rust
# #[derive(bon::Builder)]
# struct Example {
#     a: u32,
#     b: Option<u32>,
# }
#
# use example_builder::{IsUnset, IsComplete};
#
# impl<State: example_builder::State> ExampleBuilder<State> {
#     fn build_with_default_b(self) -> Example
#     where
#         State: IsComplete,
#         State::B: IsUnset,
#     {
#         self.b(42).build()
#     }
# }
# ```
#
# This code wouldn't compile without this feature enabled, because `State: IsComplete`
# wouldn't automatically imply `State::A: IsSet`, so the builder type state returned
# after `self.b()` doesn't imply that the member `a` is set, and thus `build()`
# can't be called.
#
# Huge thanks to @harudagondi for suggesting the name of this cargo feature!
implied-bounds = ["bon-macros/implied-bounds"]

# üî¨ Experimental! There may be breaking changes to this feature between *minor* releases,
# however, compatibility within patch releases is guaranteed though.
#
# This feature enables the #[builder(overwritable)] attribute that can be used to
# allow overwriting already set fields in the builder. Without this attribute it's
# not possible to set the same member twice in the builder, a compile error would be
# generated.
#
# See more info at https://bon-rs.com/reference/builder/top-level/overwritable.
#
# We are considering stabilizing this attribute if you have a use for it. Please leave
# a üëç reaction under the issue https://github.com/elastio/bon/issues/149 if you need
# this attribute. It would also be cool if you could leave a comment under that issue
# describing your use case for it.
experimental-overwritable = ["bon-macros/experimental-overwritable"]
