# Overview

`bon` is a Rust crate for generating type-safe builders for functions and structs.

## Builder for a function

`bon` can turn a function with many positional parameters into a function with "named" parameters via a builder. It's as easy as placing `#[builder]` macro on top of your function.

**Example:**

```rust
use bon::builder;

#[builder] // [!code highlight]
fn greet(name: &str, age: u32) -> String {
    format!("Hello {name} with age {age}!")
}

let greeting = greet()
    .name("Bon")
    .age(24)
    .call();

assert_eq!(greeting, "Hello Bon with age 24!");
```

::: tip

Many things are customizable with additional attributes. See the [`#[builder]` macro reference](../reference/builder) for details.

:::

## Builder for an associated method

You can also generate a builder for associated methods. For this to work you need to add `#[bon]` macro on top of the `impl` block additionally.

**Example:**

```rust
use bon::bon;

struct Counter {
    val: u32,
}

#[bon] // <- this macro is required on the impl block // [!code highlight]
impl Counter {
    #[builder] // [!code highlight]
    fn new(initial: Option<u32>) -> Self {
        Self {
            val: initial.unwrap_or_default(),
        }
    }

    #[builder] // [!code highlight]
    fn increment(&mut self, diff: u32) {
        self.val += diff;
    }
}

let mut counter = Counter::builder()
    .initial(3)
    .build();

counter
    .increment()
    .diff(3)
    .call();

assert_eq!(counter.val, 6);
```

::: details Why is that `#[bon]` macro on top of the `impl` block required? ü§î (feel free to skip)

There are a couple of technical reasons.

First of all, it's the lack of surrounding context given to a proc macro in Rust. A proc macro sees only the syntax it is placed on top of. For example, the `#[builder]` macro inside of the `impl` block can't see the `impl Counter` part of the impl block above it. However, it needs that information to tell the actual type of `Self`.

Second, `#[builder]` proc macro generates new items such as the builder struct type definition, which it needs to output **adjecently** to the `impl` block itself. However, proc macros in Rust can only modify the part of the syntax they are placed on and generate new items on the same level of nesting. The `#[builder]` macro inside of the impl block can't just break out of it.

:::

::: details Why does it compile without an import of `bon::builder`? ü§î (feel free to skip)

This is because there is no separate `#[builder]` proc macro running in this case. Only the `#[bon]` macro handles code generation, it's an active attribute, while `#[builder]` is a dumb inert data attribute.

It wouldn't harm if `bon::builder` was imported. It won't shadow the inert `#[builder]` attribute, but the import of that macro will be reported as unused by the compiler.

See [the Rust Reference](https://doc.rust-lang.org/reference/attributes.html#active-and-inert-attributes) for details about active and inert attributes.

:::


To follow usual Rust's builder naming conventions `bon` treats the `new` method specially.

Method name        | Start function name | Finish function name
-------------------| ------------------- | --------------------
`new`              | `builder`           | `build`
`{any_other_name}` | `{any_other_name}`  | `call`

## Builder for a struct

`bon` supports the classic pattern of annotating a struct to generate a builder.

**Example:**

```rust
use bon::builder;

#[builder]
struct User {
    id: u32,
    name: String,
}

let user = User::builder()
    .id(1)
    .name("Bon")
    .build();

assert_eq!(user.id, 1);
assert_eq!(user.name, "Bon");
```

::: tip

`#[builder]` on a struct generates builder API that is fully compatible with placing `#[builder]` on the `new()` method with the signature similar to struct's fields. See [compatibility](./compatibility#moving-builder-from-the-struct-to-the-new-method) page for details.

:::

## Type safe. No panics

The builders generated by `#[builder]` are all type-safe. They use the typestate pattern to make sure all required values are filled and setter methods aren't called repeatedly to prevent unintentional overwrites and typos. If something is wrong, a compile error will be created. There are no potential panics and `unwrap()` calls inside of the builder.

## Everything you want is already default

The generated builders provide ergonomic API by default. You usually won't need to override anything.

### `Option<T>` makes the setter optional

If your function argument or struct field (or member for short) is of type `Option<T>`, then the generated builder will not enforce the caller to invoke the setter for this member, defaulting to `None`.

It also generates two setters: one that accepts `T` and the other accepts `Option<T>` to avoid wrapping values with `Some()` on the call site, but still be able to pass `Option<T>` value directly.

See [optional members](./optional-members) page for details.

### Automatic `Into` conversions

If your function argument or struct field is a `String`, then you'd like to be able to pass `&str` in the setter. To do this you'd want the setter to accept a parameter of type `impl Into<String>`.

`bon` does that by default not only for `String`s. You may've seen this in action in the example code snippets above where we don't call `.to_owned()` or `.to_string()` on string literals. See [`Into` conversions](./into-conversions) for details.

## Supported syntax for functions

`#[builder]` attribute works almost with any kind of function that uses any available Rust syntax.
All of the following is supported.

- Functions can return any values including `Result`, `Option`, etc.
- `impl Trait` syntax is supported both in function parameters and return type.
- `async` functions.
- `unsafe` functions.
- Generic type parameters.
- Generic const parameters (const generics).
- Generic lifetimes.
- `where` clauses.
- Anonymous lifetimes, i.e. `'_` or just regular references without explicit lifetimes like `&u32`.
- Nested functions defined inside of other items bodies. E.g.
  ```rust
  fn foo() {
      // Just works
      #[bon::builder]
      fn bar() {}
  }
  ```

## What's next?

::: tip

If you like the idea of this crate, and want to say "thank you" or "keep up doing this" consider giving it a [star on Github](https://github.com/elastio/bon). Any support and contribution is appreciated üê±!

:::

You may consider reading the rest of the `Guide` section to harness the full power of `bon` and understand the decisions it makes. However, feel free to skip the docs and just use the `#[builder]` macro in your code. It's designed to be intuitive, so it'll probably do the thing you want it to do already.

If you can't firgure something out, then consult the docs and maybe use that search :mag: `Search` thing at the top to navigate. You may also create an issue in the [Github repository](https://github.com/elastio/bon) for help.

## Acknowledgments

This project was heavily inspired by such awesome crates as [`buildstructor`](https://docs.rs/buildstructor), [`typed-builder`](https://docs.rs/typed-builder) and [`derive_builder`](https://docs.rs/derive_builder). This crate was designed as an evolution of these with many lessons learned and a bunch more batteries provided.

See [alternatives](./alternatives) for comparison.

*[Member]: Struct field or a function argument
*[member]: Struct field or a function argument
*[members]: Struct fields or function arguments
