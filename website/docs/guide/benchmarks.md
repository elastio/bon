# Benchmarks

`#[builder]` generates code that is easily optimizable by the compiler. This is a zero-cost abstraction. The resulting assembler code contains no overhead of the builder syntax at all.

The comparisons below are made between regular positional function call syntax and builder syntax for functions.

## Assembly comparison

The following [Compiler Explorer page](https://godbolt.org/z/rxq6dz5vK) shows the assembly diff view. As you can see there is absolutely no difference between just calling a function as usual and using the builder.

::: info

The code for the builder was manually expanded from the `#[builder]` macro and copied into the Compiler Explorer, together with a small part of the `bon` crate to make it compile. It was done this way because Compiler Explorer doesn't support using arbitrary 3-rd party crates.

:::

![screenshot of the godbolt page](/godbolt-1.png){data-zoomable}


Note that the compiler optimizes out the builder starting at `opt-level >= 2`. At `opt-level = 1`, the assembly for the builder syntax contains some unused functions, which doesn't influence the runtime performance ([Compiler Explorer link](https://godbolt.org/z/rcM655ejG)).

## Explanation

The code generated by `#[builder]` is completely transparent to the compiler. It is basically a builder struct with methods that move values into the builder on each call. The resulting finishing method just passes the values from the builder into the positional function (for `#[builder]` on a function) or into the new struct literal (for `#[builder]` on a struct).

::: details Expand to see the example of generated code

Let's take this code as an example:

```rust
use bon::builder;

#[builder]
pub fn func(arg1: &str, arg2: u32) -> u32 {
    arg1.parse::<u32>().unwrap() + arg2
}
```

Below is the code that the `#[builder]` macro generates in this case.

The `bon::private` module used below is a private module exposed only to the code generated by `bon`'s macros. It must not be used directly, and it's marked as `#[doc(hidden)]`. The items in that module have no logic other than moving values around. Here is it's [source code](https://github.com/elastio/bon/blob/master/bon/src/private.rs).


```rust
// Uses were added manually for simplicity
use std::marker::PhantomData;
use bon::private::{Required, Set, IntoSet};

// Start function that creates the builder
fn func<'a>() -> FuncBuilder<'a> {
    FuncBuilder {
        phantom: PhantomData,
        arg1: Required::default(),
        arg2: Required::default(),
    }
}

// Original positional function was hidden under a different name
fn __orig_func(arg1: &str, arg2: u32) -> u32 {
    arg1.parse::<u32>().unwrap() + arg2
}

// A trait that stores the type state of the builder.
trait FuncBuilderState {
    type Arg1;
    type Arg2;
}

impl<Arg1, Arg2> FuncBuilderState for (Arg1, Arg2) {
    type Arg1 = Arg1;
    type Arg2 = Arg2;
}

// The builder itself.
struct FuncBuilder<'a, State = (Required<&'a str>, Required<u32>)>
where
    State: FuncBuilderState
{
    phantom: PhantomData<(&'a str, u32, State)>,
    arg1: State::Arg1,
    arg2: State::Arg2,
}

impl<'a, State: FuncBuilderState> FuncBuilder<'a, State>
where
    State::Arg1: IntoSet<&'a str>,
    State::Arg2: IntoSet<u32>,
{
    /// Finishes building and performs the requested action
    fn call(self) -> u32 {
        // Just passes the values from the builder to the positional function.
        __orig_func(
            IntoSet::into_set(self.arg1).into_inner(),
            IntoSet::into_set(self.arg2).into_inner(),
        )
    }
}

// Setters. They just move values from the builder into a new builder struct.
// Nothing fancy
impl<'a, State> FuncBuilder<'a, State>
where
    State: FuncBuilderState<Arg1 = Required<&'a str>>
{
    fn arg1(self, value: &'a str) -> FuncBuilder<'a, (Set<&'a str>, State::Arg2)> {
        FuncBuilder {
            phantom: PhantomData,
            arg1: Set::new(value),
            arg2: self.arg2,
        }
    }
}

impl<'a, State> FuncBuilder<'a, State>
where
    State: FuncBuilderState<Arg2 = Required<u32>>
{
    fn arg2(self, value: u32) -> FuncBuilder<'a, (State::Arg1, Set<u32>)> {
        FuncBuilder {
            phantom: PhantomData,
            arg1: self.arg1,
            arg2: Set::new(value),
        }
    }
}
```

This code is fully compilable if you wonder.

:::


This code is extremely easy to inline for the compiler. Once it inlines all the function calls of the builder syntax it can remove unnecessary moves of values across function calls that were inlined. The remaining assembly code is the same as if there was no builder at all.
