# Compilation Benchmarks

This page describes the results of benchmarking the performance of compiling code generated by `bon`'s and other alternative crates' builder macros.

There are two things contributing to compile times:

1. Compiling the proc macro crate into a dynamic library.
2. Compiling the code generated by the proc macros.

The benchmarks here intentionally exclude `1` from measurements. This is because the proc macro crate itself compiles blazingly fast ⚡. For example, once you add `bon` as a dependency, its will compiled only once and never recompiled during incremental rebuilds.

## Measurements

The benchmarks measure the time it takes to run `cargo build` against a crate that uses `#[derive(Builder)]` for the given number of structs with the given number of fields in each of them.

### 100 structs with 10 fields

| Builder crate    | Compile time |
| ---------------- | ------------ |
| `bon`            | `2.340s`     |
| `typed-builder`  | `1.831s`     |
| `derive_builder` | `1.026s`     |
| no macros        | `0.113s`     |

### 10 structs with 50 fields

| Builder crate    | Compile time |
| ---------------- | ------------ |
| `bon`            | `2.096s`     |
| `typed-builder`  | `2.088s`     |
| `derive_builder` | `0.449s`     |
| no macros        | `0.112s`     |

## Summary

As you can see the code generated by `bon` takes more time to compile than with other builder crates. It is close to `typed-builder` in the [second](#10-structs-with-50-fields) benchmark though.

Now don't rush to conclusions ✋. To be fair, the amount of features and improvements `bon` provides over other crates is worth the slightly higher compilation time. The difference isn't that critical with the number of structs/fields used in the measurements here.

However, let's address some questions.

### Why `derive_builder` is fastest to compile?

The main contributor to compile times of code generated by `bon` and `typed-builder` is their usage of generics to represent the type state. The builders generated by `derive_builder` don't use any generics.

The main downside of `derive_builder`'s approach is that its finishing `build()` method always returns a `Result`, because it needs to validate, that all required fields were set **at runtime**.

### Why `bon` loses to `typed-builder` in compilation perf?

`bon`'s generated code is a bit more complex than `typed-builder`'s, because `bon` generates additional traits and types to expose a nice and stable [typestate API](../typestate-api).

This is also done to reduce the builder's type signature size and reduce the noisy generic in the documentation generated by `rustdoc`. In fact, the difference in the generated docs between `bon` and `typed-builder` is [drastic](../alternatives#documentation-comparison).

### Can `bon` do better for compile times?

Unfortunately, it's a tradeoff.
